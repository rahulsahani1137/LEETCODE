#include <iostream>
#include <queue>

using namespace std;

struct Process {
  int pid; // Process ID
  int arrival_time; // Arrival time
  int burst_time; // Burst time
  int remaining_time; // Remaining burst time
  int waiting_time; // Waiting time
  int turn_around_time; // Turnaround time
};

bool compareArrivalTime(const Process& p1, const Process& p2) {
  return p1.arrival_time < p2.arrival_time;
}

// Non-preemptive FCFS
void nonPreemptiveFCFS(Process* processes, int n) {
  sort(processes, processes + n, compareArrivalTime); // Sort processes by arrival time

  for (int i = 0; i < n; ++i) {
    // Update remaining time
    processes[i].remaining_time = processes[i].burst_time;

    // Execute the process
    while (processes[i].remaining_time > 0) {
      // Calculate waiting time
      for (int j = i + 1; j < n; ++j) {
        processes[j].waiting_time++;
      }

      // Reduce remaining time
      processes[i].remaining_time--;
    }

    // Calculate turn around time
    processes[i].turn_around_time = processes[i].waiting_time + processes[i].burst_time;
  }
}

// Preemptive FCFS
void preemptiveFCFS(Process* processes, int n) {
  sort(processes, processes + n, compareArrivalTime); // Sort processes by arrival time

  int current_time = 0;
  priority_queue<Process, vector<Process>, compareArrivalTime> ready_queue;

  while (!ready_queue.empty() || current_time < processes[n - 1].arrival_time + processes[n - 1].burst_time) {
    // Add processes to ready queue
    for (int i = 0; i < n; ++i) {
      if (processes[i].arrival_time <= current_time && processes[i].remaining_time > 0) {
        ready_queue.push(processes[i]);
      }
    }

    // If ready queue is empty, move to next time unit
    if (ready_queue.empty()) {
      current_time++;
      continue;
    }

    // Get the process with the shortest remaining time
    Process current_process = ready_queue.top();
    ready_queue.pop();

    // Update current time and remaining time
    current_time++;
    current_process.remaining_time--;

    // Update waiting time for other processes
    for (Process& process : ready_queue) {
      process.waiting_time++;
    }

    // If process is finished, calculate turn around time
    if (current_process.remaining_time == 0) {
      current_process.turn_around_time = current_time - current_process.arrival_time;
    }
  }
}

int main() {
  // Number of processes
  int n;
  cout << "Enter the number of processes: ";
  cin >> n;

  // Array of processes
  Process processes[n];

  // Get process details
  for (int i = 0; i < n; ++i) {
    processes[i].pid = i + 1;
    cout << "Enter arrival time for process " << processes[i].pid << ": ";
    cin >> processes[i].arrival_time;
    cout << "Enter burst time for process " << processes[i].pid << ": ";
    cin >> processes[i].burst_time;
    processes[i].remaining_time = processes[i].burst_time;
  }

  // Choose scheduling algorithm
  int choice;
  cout << "Choose scheduling algorithm: (1) Non-preemptive FCFS, (2) Preemptive FCFS: ";
  cin >> choice;

  switch (choice) {
    case 1:
      nonPreemptiveFCFS(processes, n);
      break;
    case 2:
      preemptiveFCFS(processes, n);
      break;
    default:
      cout << "Invalid choice!" << endl;
      return 1;
